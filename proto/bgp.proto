syntax = "proto3";

package bgp;

// ============================================================================
// BGP Service
// ============================================================================
service BgpService {
    rpc AddPeer(AddPeerRequest) returns (AddPeerResponse);
    rpc RemovePeer(RemovePeerRequest) returns (RemovePeerResponse);
    rpc DisablePeer(DisablePeerRequest) returns (DisablePeerResponse);
    rpc EnablePeer(EnablePeerRequest) returns (EnablePeerResponse);
    rpc ResetPeer(ResetPeerRequest) returns (ResetPeerResponse);
    rpc ListPeers(ListPeersRequest) returns (ListPeersResponse);
    rpc ListPeersStream(ListPeersRequest) returns (stream Peer);
    rpc GetPeer(GetPeerRequest) returns (GetPeerResponse);
    rpc AddRoute(AddRouteRequest) returns (AddRouteResponse);
    rpc AddRouteStream(stream AddRouteRequest) returns (AddRouteStreamResponse);
    rpc RemoveRoute(RemoveRouteRequest) returns (RemoveRouteResponse);
    rpc ListRoutes(ListRoutesRequest) returns (ListRoutesResponse);
    rpc ListRoutesStream(ListRoutesRequest) returns (stream Route);
    rpc GetServerInfo(GetServerInfoRequest) returns (GetServerInfoResponse);
    rpc AddBmpServer(AddBmpServerRequest) returns (AddBmpServerResponse);
    rpc RemoveBmpServer(RemoveBmpServerRequest) returns (RemoveBmpServerResponse);
    rpc ListBmpServers(ListBmpServersRequest) returns (ListBmpServersResponse);

    // Policy management
    rpc AddDefinedSet(AddDefinedSetRequest) returns (AddDefinedSetResponse);
    rpc RemoveDefinedSet(RemoveDefinedSetRequest) returns (RemoveDefinedSetResponse);
    rpc ListDefinedSets(ListDefinedSetsRequest) returns (ListDefinedSetsResponse);
    rpc AddPolicy(AddPolicyRequest) returns (AddPolicyResponse);
    rpc RemovePolicy(RemovePolicyRequest) returns (RemovePolicyResponse);
    rpc ListPolicies(ListPoliciesRequest) returns (ListPoliciesResponse);
    rpc SetPolicyAssignment(SetPolicyAssignmentRequest) returns (SetPolicyAssignmentResponse);
}

message GetServerInfoRequest {}

message GetServerInfoResponse {
    string listen_addr = 1;
    uint32 listen_port = 2;
    uint64 num_routes = 3;  // Total number of routes in RIB
}

// Action when max prefix limit is reached
enum MaxPrefixAction {
    TERMINATE = 0;  // Send CEASE and close session
    DISCARD = 1;    // Drop new prefixes, keep session
}

// Max prefix limit configuration
message MaxPrefixSetting {
    uint32 limit = 1;
    MaxPrefixAction action = 2;
}

// Graceful Restart configuration (RFC 4724)
message GracefulRestartConfig {
    optional bool enabled = 1;
    optional uint32 restart_time_secs = 2;  // Max 4095 per RFC 4724
}

// Per-peer session configuration (RFC 4271 Section 8.1 optional attributes)
message SessionConfig {
    optional uint64 idle_hold_time_secs = 1;      // Auto-reconnect delay. Unset disables (default: 30s)
    optional bool damp_peer_oscillations = 2;     // Exponential backoff on failures (default: true)
    optional bool allow_automatic_stop = 3;       // Auto-stop on max prefix exceeded (default: true)
    optional bool passive_mode = 4;               // Wait for remote to connect (default: false)
    optional uint64 delay_open_time_secs = 5;     // Delay before sending OPEN. Unset disables
    optional MaxPrefixSetting max_prefix = 6;
    optional bool send_notification_without_open = 7;  // Allow NOTIFICATION before OPEN (default: false)
    optional uint64 min_route_advertisement_interval_secs = 8;  // MRAI timer (RFC 4271 9.2.1.1, default: 0)
    optional GracefulRestartConfig graceful_restart = 9;  // Graceful Restart settings
    optional uint32 port = 10;  // Remote BGP port (default: 179)
    optional bool rr_client = 11;  // RFC 4456: Mark peer as route reflector client
}

// Add peer request/response
message AddPeerRequest {
    string address = 1;              // Peer IP address (e.g., "192.168.1.1")
    optional SessionConfig config = 2;  // Omit for all defaults
}

message AddPeerResponse {
    bool success = 1;
    string message = 2;
}

// Remove peer request/response
message RemovePeerRequest {
    string address = 1;
}

message RemovePeerResponse {
    bool success = 1;
    string message = 2;
}

// Disable peer request/response (RFC 4486 Administrative Shutdown)
message DisablePeerRequest {
    string address = 1;
}

message DisablePeerResponse {}

// Enable peer request/response (RFC 4486 undo Administrative Shutdown)
message EnablePeerRequest {
    string address = 1;
}

message EnablePeerResponse {}

// Reset type for ResetPeer operation
enum ResetType {
    SOFT_IN = 0;
    SOFT_OUT = 1;
    SOFT = 2;
    HARD = 3;
}

// Address Family Identifier
enum Afi {
    IPV4 = 0;
    IPV6 = 1;
}

// Subsequent Address Family Identifier
enum Safi {
    UNICAST = 0;
}

// Reset peer request/response (flexible reset supporting multiple types and AFI/SAFI)
message ResetPeerRequest {
    string address = 1;
    ResetType reset_type = 2;
    optional Afi afi = 3;      // If unset, applies to all negotiated AFIs
    optional Safi safi = 4;    // If unset, applies to all negotiated SAFIs for the AFI(s)
}

message ResetPeerResponse {}

// List peers request/response
message ListPeersRequest {}

message ListPeersResponse {
    repeated Peer peers = 1;
}

// Get peer request/response
message GetPeerRequest {
    string address = 1;  // Peer IP address
}

message GetPeerResponse {
    Peer peer = 1;
    PeerStatistics statistics = 2;
}

// Peer statistics
message PeerStatistics {
    uint64 open_sent = 1;
    uint64 keepalive_sent = 2;
    uint64 update_sent = 3;
    uint64 notification_sent = 4;
    uint64 open_received = 5;
    uint64 keepalive_received = 6;
    uint64 update_received = 7;
    uint64 notification_received = 8;
}

// BGP FSM states
enum BgpState {
    IDLE = 0;
    CONNECT = 1;
    ACTIVE = 2;
    OPEN_SENT = 3;
    OPEN_CONFIRM = 4;
    ESTABLISHED = 5;
}

// Administrative state of a peer
enum AdminState {
    UP = 0;
    DOWN = 1;
    PREFIX_LIMIT_EXCEEDED = 2;
}

// Peer information
message Peer {
    string address = 1;
    uint32 asn = 2;
    BgpState state = 3;
    AdminState admin_state = 4;
    repeated string import_policies = 5;  // Names of import policies assigned to this peer
    repeated string export_policies = 6;  // Names of export policies assigned to this peer
}

// Add route request/response
message AddRouteRequest {
    string prefix = 1;      // CIDR format (e.g., "10.0.0.0/24")
    string next_hop = 2;    // IPv4 address (e.g., "192.168.1.1")
    Origin origin = 3;      // Route origin
    repeated AsPathSegment as_path = 4; // Optional AS_PATH (empty = locally originated)
    optional uint32 local_pref = 5;     // Optional LOCAL_PREF (defaults to 100)
    optional uint32 med = 6;            // Optional MULTI_EXIT_DISC
    bool atomic_aggregate = 7;          // ATOMIC_AGGREGATE attribute
    repeated uint32 communities = 8;    // BGP Communities (RFC 1997)
    repeated ExtendedCommunity extended_communities = 9; // Extended Communities (RFC 4360)
    repeated LargeCommunity large_communities = 10; // Large Communities (RFC 8092)
    // RFC 4456: Route Reflector attributes
    optional string originator_id = 11;  // ORIGINATOR_ID (IPv4 address)
    repeated string cluster_list = 12;   // CLUSTER_LIST (list of IPv4 addresses)
}

message AddRouteResponse {
    bool success = 1;
    string message = 2;
}

message AddRouteStreamResponse {
    uint64 count = 1;  // Number of routes successfully added
    string message = 2;
}

// Remove route request/response
message RemoveRouteRequest {
    string prefix = 1;      // CIDR format (e.g., "10.0.0.0/24")
}

message RemoveRouteResponse {
    bool success = 1;
    string message = 2;
}

// BGP Origin attribute
enum Origin {
    IGP = 0;
    EGP = 1;
    INCOMPLETE = 2;
}

// AS_PATH segment type
enum AsPathSegmentType {
    AS_SET = 0;
    AS_SEQUENCE = 1;
}

// AS_PATH segment
message AsPathSegment {
    AsPathSegmentType segment_type = 1;
    repeated uint32 asns = 2;
}

// Table type for route queries
enum RibType {
    GLOBAL = 0;   // Global RIB (Loc-RIB)
    ADJ_IN = 1;   // Per-peer Adj-RIB-In
    ADJ_OUT = 2;  // Per-peer Adj-RIB-Out (computed on-demand)
}

// List routes request/response
message ListRoutesRequest {
    optional RibType rib_type = 1;  // Defaults to GLOBAL
    optional string peer_address = 2;    // Required for ADJ_IN and ADJ_OUT
}

message ListRoutesResponse {
    repeated Route routes = 1;
}

// Route information
message Route {
    string prefix = 1;      // CIDR format
    repeated Path paths = 2; // Multiple paths to same prefix
}

// Path information
message Path {
    Origin origin = 1;
    repeated AsPathSegment as_path = 2;
    string next_hop = 3;
    string peer_address = 4;
    optional uint32 local_pref = 5;
    optional uint32 med = 6;
    bool atomic_aggregate = 7;
    repeated UnknownAttribute unknown_attributes = 8;
    repeated uint32 communities = 9;
    repeated ExtendedCommunity extended_communities = 10;
    repeated LargeCommunity large_communities = 11;
    // RFC 4456: Route Reflector attributes
    optional string originator_id = 12;  // ORIGINATOR_ID (IPv4 address)
    repeated string cluster_list = 13;   // CLUSTER_LIST (list of IPv4 addresses)
    // RFC 7911: ADD-PATH identifiers
    uint32 local_path_id = 14;                // Locally assigned path ID (0 = not allocated)
    optional uint32 remote_path_id = 15;      // Path ID received from peer (absent = no ADD-PATH)
}

// Unknown attribute
message UnknownAttribute {
    uint32 attr_type = 1;
    uint32 flags = 2;
    bytes value = 3;
}

// Large Community (RFC 8092)
message LargeCommunity {
    uint32 global_admin = 1;
    uint32 local_data_1 = 2;
    uint32 local_data_2 = 3;
}

// Extended Community (RFC 4360, RFC 5668, RFC 9012, draft-ietf-idr-link-bandwidth)
message ExtendedCommunity {
  oneof community {
    TwoOctetAsSpecific two_octet_as = 1;
    IPv4AddressSpecific ipv4_address = 2;
    FourOctetAsSpecific four_octet_as = 3;
    LinkBandwidth link_bandwidth = 4;
    Color color = 5;
    Encapsulation encapsulation = 6;
    RouterMac router_mac = 7;
    Opaque opaque = 8;
    Unknown unknown = 9;
  }

  message TwoOctetAsSpecific {
    bool is_transitive = 1;
    uint32 sub_type = 2;        // 0x02=Route Target, 0x03=Route Origin
    uint32 asn = 3;             // 16-bit ASN (validate <= 65535)
    uint32 local_admin = 4;     // 32-bit local administrator
  }

  message IPv4AddressSpecific {
    bool is_transitive = 1;
    uint32 sub_type = 2;
    string address = 3;         // IPv4 dotted notation (e.g., "192.168.1.1")
    uint32 local_admin = 4;     // 16-bit local administrator (validate <= 65535)
  }

  message FourOctetAsSpecific {
    bool is_transitive = 1;
    uint32 sub_type = 2;
    uint32 asn = 3;             // 32-bit ASN
    uint32 local_admin = 4;     // 16-bit local administrator (validate <= 65535)
  }

  message LinkBandwidth {
    bool is_transitive = 1;     // Type can be 0x00 (transitive) or 0x40 (non-transitive)
    uint32 asn = 2;             // 16-bit AS number (validate <= 65535)
    float bandwidth = 3;        // Bandwidth in bytes/sec (IEEE 754 float32)
  }

  message Color {
    bool is_transitive = 1;     // Type can be 0x03 (transitive) or 0x43 (non-transitive)
    uint32 color = 2;           // 32-bit color value (RFC 9012)
  }

  message Encapsulation {
    bool is_transitive = 1;     // Type can be 0x03 (transitive) or 0x43 (non-transitive)
    uint32 tunnel_type = 2;     // 16-bit tunnel type (e.g., 8=VXLAN, 15=SR Policy, RFC 9012)
  }

  message RouterMac {
    bool is_transitive = 1;     // Type 0x06 is always transitive for EVPN
    bytes mac_address = 2;      // 6-byte MAC address (RFC 9012)
  }

  message Opaque {
    bool is_transitive = 1;
    bytes value = 2;            // 6 bytes of opaque data (validate length)
  }

  message Unknown {
    uint32 type_code = 1;       // Full type octet from wire format
    bytes value = 2;            // 7 bytes (subtype + 6-byte value, validate length)
  }
}

// BMP server management
message AddBmpServerRequest {
    string address = 1;  // IP:PORT format (e.g., "127.0.0.1:11019")
    optional uint64 statistics_timeout = 2;  // Statistics interval in seconds (0 or unset = disabled)
}

message AddBmpServerResponse {
    bool success = 1;
    string message = 2;
}

message RemoveBmpServerRequest {
    string address = 1;
}

message RemoveBmpServerResponse {
    bool success = 1;
    string message = 2;
}

message ListBmpServersRequest {}

message ListBmpServersResponse {
    repeated string addresses = 1;
}

// ============================================================================
// Policy Management
// ============================================================================

// Defined Set Management
message AddDefinedSetRequest {
    DefinedSetConfig set = 1;
    bool replace = 2;  // If true, replace existing set
}

message AddDefinedSetResponse {
    bool success = 1;
    string message = 2;
}

message RemoveDefinedSetRequest {
    string set_type = 1;  // "prefix-set", "as-path-set", "community-set", "neighbor-set"
    string name = 2;
    bool all = 3;  // Remove all sets of this type
}

message RemoveDefinedSetResponse {
    bool success = 1;
    string message = 2;
}

message ListDefinedSetsRequest {
    optional string set_type = 1;  // Filter by type, empty = all types
    optional string name = 2;      // Filter by name
}

message ListDefinedSetsResponse {
    repeated DefinedSetInfo sets = 1;
}

message DefinedSetInfo {
    string set_type = 1;
    string name = 2;
    oneof set_data {
        PrefixSetData prefix_set = 3;
        AsPathSetData as_path_set = 4;
        CommunitySetData community_set = 5;
        NeighborSetData neighbor_set = 6;
        LargeCommunitySetData large_community_set = 7;
        ExtendedCommunitySetData ext_community_set = 8;
    }
}

message PrefixSetData {
    repeated PrefixMatch prefixes = 1;
}

message PrefixMatch {
    string prefix = 1;
    optional string masklength_range = 2;
}

message AsPathSetData {
    repeated string patterns = 1;
}

message CommunitySetData {
    repeated string communities = 1;
}

message ExtendedCommunitySetData {
    repeated string ext_communities = 1;  // Format: "rt:65000:100" or hex
}

message LargeCommunitySetData {
    repeated string large_communities = 1;  // Format: "GA:LD1:LD2"
}

message NeighborSetData {
    repeated string addresses = 1;
}

// For AddDefinedSetRequest
message DefinedSetConfig {
    string set_type = 1;
    string name = 2;
    oneof config {
        PrefixSetData prefix_set = 3;
        AsPathSetData as_path_set = 4;
        CommunitySetData community_set = 5;
        NeighborSetData neighbor_set = 6;
        LargeCommunitySetData large_community_set = 7;
        ExtendedCommunitySetData ext_community_set = 8;
    }
}

// Policy Management
message AddPolicyRequest {
    string name = 1;
    repeated StatementConfig statements = 2;
}

message AddPolicyResponse {
    bool success = 1;
    string message = 2;
}

message StatementConfig {
    optional ConditionsConfig conditions = 1;
    optional ActionsConfig actions = 2;
}

message ConditionsConfig {
    optional MatchSetRef match_prefix_set = 1;
    optional MatchSetRef match_neighbor_set = 2;
    optional MatchSetRef match_as_path_set = 3;
    optional MatchSetRef match_community_set = 4;
    optional MatchSetRef match_large_community_set = 5;
    optional string prefix = 6;  // Direct prefix match
    optional string neighbor = 7;  // Direct neighbor match
    optional MatchSetRef match_ext_community_set = 8;
}

message MatchSetRef {
    string set_name = 1;
    string match_option = 2;  // "any", "all", "invert"
}

message ActionsConfig {
    optional bool accept = 1;
    optional bool reject = 2;
    optional uint32 local_pref = 3;
    optional uint32 med = 4;
    repeated string add_communities = 5;
    repeated string remove_communities = 6;
}

message RemovePolicyRequest {
    string name = 1;
}

message RemovePolicyResponse {
    bool success = 1;
    string message = 2;
}

message ListPoliciesRequest {
    optional string name = 1;  // Filter by name
}

message ListPoliciesResponse {
    repeated PolicyInfo policies = 1;
}

message PolicyInfo {
    string name = 1;
    repeated StatementInfo statements = 2;
}

message StatementInfo {
    ConditionsConfig conditions = 1;
    ActionsConfig actions = 2;
}

// Policy Assignment
message SetPolicyAssignmentRequest {
    string peer_address = 1;
    string direction = 2;  // "import" or "export"
    repeated string policy_names = 3;
    optional string default_action = 4;  // "accept" or "reject"
}

message SetPolicyAssignmentResponse {
    bool success = 1;
    string message = 2;
}
